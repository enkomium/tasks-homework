// КРАТКОЕ СОДЕРЖАНИЕ ТОГО ЧТО ЕСТЬ:
// - РАСПЫЛЕНИЕ
// - ГЛУБОКАЯ ДЕСТРУКТУРИЗАЦИЯ
// - ДЕСТРУКТУРИЗАЦИЯ МАССИВОВ
// - ДЕСТРУКТУРИЗАЦИЯ со СБОРОМ - REST
// - ПАТТЕР ОБЪЕКТ НАСТРОЕК!
// --------------------------------------------------------------------------------------------------------------------------------
// Обращения и т.д.
// --------------------------------------------------------------------------------------------------------------------------------
// Восновном через цепочку вызовов, можно через квадратные скобки, где указываем имя свойства как строку ['name']
// либо в квадратных скобках пишем имя переменной которая где-то объявлена и содержит название свойства.
// так же при обращении к массиву через цепочку можно указать его индекс в квадратныъх скобках - object.array[1]

// что бы присвоить новое значение или изменить его, так же обращаемся через цепочку вызовов, 
// либо квадратные скобки и указываем новое значение. = ...
// новые свойства создаются по тому же принципу что написано выше 

// --------------------------------------------------------------------------------------------------------------------------------
// Перебор Объекта
// --------------------------------------------------------------------------------------------------------------------------------
// Через цикл for (key in object) {}, key - ключ, object[key] - значение.
// При переборе через for in нужно делать проверку на собственные свойства, т.е. не наследованные,
// Так как если Объект был наследован, то мы переберем и свойства с родительского Объекта!
// Для этого делаем проверку с использованием hasOwnProperty() - возращает true или false. и перебираем только собсвенные свойства.
// for(const key in object){
//     if(Object.hasOwnProperty(key)){
//         console.log(key);
//         console.log(Object[key]);
//     }
// }
// hasOwnProperty() - полезная штука, когда мы хотим проверить есть ли такой КЛЮЧ/свойство у Объекта вобще по условию!!!
// ВАЖНО что он смотрит только на то как называется САМ КЛЮЧ!!!!
// В основном использовать когда не знаем структуру объекта или сомневаемся что такое свойство есть или нет!!!

// Через цикл for of используя методы keys(), values() и entries().
// keys() - возвращает массив ключей, если ключей/свойств нет, возвращает пустой массив.
// values() - возвращает массив значений, если значений нет, возвращает пустой массив.
// entries() - возвращает массив ключ-значение.(масив массивов)

// --------------------------------------------------------------------------------------------------------------------------------
// Деструктуризация
// --------------------------------------------------------------------------------------------------------------------------------
// ПО сути это распаковка свойств объекта в отдельные переменные! Что бы потом было проще к ним обращаться и с ними работать!
// const highTemperatures = {
//     yesterday: 28,
//     today: 26,
//     tomorrow: 33,
//   };

// const { yesterday, today, tomorrow } = highTemperatures;

// при деструктуризации несуществующих свойств, можно задать переменным значения по умолчанию, 
// которые будут присвоены только в случае когда в объекте нет свойства с таким именем.
// const { yesterday, today, tomorrow, icon = "https://www.flaticon.com/svg/static.svg" } = highTemperatures;

// При деструктуризации можно изменить имя переменной в которую распаковывается значение свойства. 
// Сначала пишем имя свойства из которого хотим получить значение, 
// после чего ставим двоеточие и пишем имя переменной в которую необходимо поместить значение этого свойства.
// const { 
//     yesterday: highYesterday, 
//     today: highToday, 
//     tomorrow: highTomorrow, 
//     icon: highIcon = "https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg",
//     } = highTemperatures;

// Деструктуризация в цикле!
// При переборе массива объектов циклом for...of можно деструктуризировать свойства объекта в локальные переменные в теле цикла.
// for (const book of books) {
//   const { title, author, rating } = book;
// }
// Если в объекте немного свойств, деструктуризацию можно выполнить прямо в месте объявления переменной book.
// for (const { title, author, rating } of books) {}

// Деструктуризация вложенных свойств!
// const forecast = {  ----------- ОБЪЕКТ
//     today: {
//       low: 28,
//       high: 32,
//       icon: "https://www.flaticon.com/svg/static/icons/svg/861/861059.svg",
//     },
//     tomorrow: {
//       low: 27,
//       high: 31,
//     },
//   };

// const {  ----------- ДЕСТРУКТУРИЗАЦИЯ С ВЛОЖЕННОСТЬЮ
//     today: {
//       high: highToday,
//       low: lowToday,
//       icon: todayIcon = "https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg",
//     },
//     tomorrow: {
//       high: highTomorrow,
//       low: lowTomorrow,
//       icon: tomorrowIcon = "https://www.flaticon.com/svg/static/icons/svg/2204/2204346.svg",
//     }
//   } = forecast;

// Объект настроек
// Передача в функцию Объекта и его распаковка в функции, если 3 или более параметров!
// Если параметров мало, можно распаковать прямо в теле функции, на подобе как в цикле for of при переборе массива Объектов.
// function calculateMeanTemperature(forecast) {
//     const { 
//       today: { low: todayLow, high:  todayHigh, }, --------РАСПАКОВАЛИ ЕгО В ФУНКЦИИы 2.
//       tomorrow: { low: tomorrowLow, high: tomorrowHigh, }
//     } = forecast;
    
//     return (todayLow + todayHigh + tomorrowLow + tomorrowHigh) / 4;
//   }

//   calculateMeanTemperature({  --------ПЕРЕДАЛИОБЪЕКТ  НАСТРОЕК В ФУНКЦИЮ 1.
//     today: { low: 10, high: 20 },
//     tomorrow: { low: 20, high: 30 }
//   });

// Распыление!
// Синтаксис ... (spread) позволяет распылить коллекцию элементов (массив, строку или объект)
// распыление не изменяет оригинальную коллекцию, то есть делается копия каждого элемента.
// Например, метод Math.max(аргументы) ищет и возвращает самый большой из аргументов (чисел), 
// то есть ожидает не массив значений, а произвольное количество аргументов.

// Расылим в него массив и нйдем нужные нам значения:
// const scores = [89, 64, 42, 17, 93, 51, 26];
// const bestScore = Math.max(...scores); - самый высокий балл
// const worstScore = Math.min(...scores); - самый низкий балл

// Можно склеить произвольное количество массивов в один новый без slice() и concat()
// const firstGroupScores = [64, 42, 93];
// const secondGroupScores = [89, 14, 51, 26];
// const allScores = [...firstGroupScores, ...secondGroupScores]; - сделалли из 2х - 1 боольшой.

// Можно распылять Объекты в Объекты, но ПОМНИТЬ что новые свойства перезаписывают старые! То есть важен ПОРЯДОК распыления!!!

// Сбор!
// Тоже с тремя точками но используется для объединения коллекций в одну коллекцию.
// На выходе получаем массив собранных значений.

// КАК ОТЛИЧИТЬ?
// Сбор (rest): Собирает элементы в массив или объект. Используется в параметрах функции или при деструктуризации.
// function foo(...args) {} // Сбор аргументов
// const [a, b, ...rest] = [1, 2, 3, 4]; // Сбор оставшихся элементов

// Распыление (spread): Разбивает массив или объект на отдельные элементы. 
// Используется при вызове функции, создании массивов или объектов.
// const arr = [1, 2, 3];
// console.log(...arr); // Распыление массива
// const newArr = [...arr]; // Распыление при создании нового массива





// Что бы обратиться к свойству которое записанно в переменной, используем квадратные скобки!
// --------------------------------------------------------------------------------------------------------------------------------
// const obj = {
//   a: 1,
//   b: 2,
//   c: 3,
// };

// const propertyName = 'c';

// console.log(obj[propertyName]);

// Короткая запись свойств!
// Если имя ключа совпадает с именем переменной, можно просто указать Переменную.
// --------------------------------------------------------------------------------------------------------------------------------
// const userName = 'Mango';
// const userEmail = 'mango@mail.ru';

// const signupData = {
//   userName,
//   userEmail,
// };

// console.log(userName);

// Вычисляемые свойства!
// Когда надо что бы Ключь (свойсво) было значение какой-то переменной!
// --------------------------------------------------------------------------------------------------------------------------------
// <input name = "color" value = "tomato"></input>

// const inputName = 'color';
// const inputValue = 'tomato';

// const colorPickerData = {
//   [inputName]: inputValue,
// };

// console.log(colorPickerData);
// Методы объекта и this при обращении к свойствам в методах
// --------------------------------------------------------------------------------------------------------------------------------
// const playlist = {
//   name: 'Мой супер плейлист',
//   rating: 5,
//   tracks: ['трек-1', 'трек-2', 'трек-3'],
//   changeName(newName) {
//     console.log('this внутри changeName: ', this);

//     this.name = newName;
//   },
//   addTrack(track) {
//     this.tracks.push(track);
//   },
//   updateRating(newRating) {
//     this.rating = newRating;
//   },
//   getTrackCount() {
//     return this.tracks.length;
//   },
// };

// console.log(playlist.getTrackCount());

// playlist.changeName('Новое имя');

// playlist.addTrack('новый трек 1');

// playlist.addTrack('новый трек 2');

// playlist.updateRating(4);

// console.log(playlist);

// --------------------------------------------------------------------------------------------------------------------------------------
// ДЕСТРУКТУРИЗАЦИЯ SPREAD и REST //////////////////////////////////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------
// РАСПЫЛЕНИЕ //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------
// Array.prototype.concat(); и аналог через Spread
// const numbers = [1, 2, 3].concat([4, 5, 6], [7, 8, 9]);
// console.log(numbers);

// const number = [4, 5, 6];

// const result = [1, 2, 3, ...number];
// console.log(result);

// const resultMax = Math.min(...result);
// console.log(resultMax);

// const arrayObj = [{ x: 1 }, { y: 2 }, { z: 3 }];
// const resultObj = [...arrayObj];
// console.log(resultObj);

// const a = { x: 1 };
// const b = { z: 3 };
// const c = Object.assign({}, a, b);
// console.log(c);

// const c = {
//   ...a,
//   name: 'Mango',
//   ...b,
// };
// console.log(c);
// --------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------
// ДЕСТРУКТУРИЗАЦИЯ (для удобства, создает локальные переменные) ///////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------
// const playlist = {
//   name: 'Мой плейлист',
//   rating: 5,
//   tracks: ['трек-1', 'трек-2', 'трек-3'],
//   trackCount: 3,
// };

// const { name, rating, tracks, trackCount } = playlist;

// Добавили переменную author со значением по умолчанию! И rating тоже.
// const { name, rating = 0, tracks, trackCount, author = 'user' } = playlist;

// Поменяли имя переменной из Обьекта trackCount на numberOfTracks и задали значение по умолчанию!
// const {
//   name,
//   rating = 0,
//   tracks,
//   trackCount: numberOfTracks = 0,
//   author = 'user',
// } = playlist;
// МОЖНО ДЕСТРУКТУРИЗИРОВАТЬ СВОЙСТВО 2 РАЗА (в 2х опирациях), НУЖНО ТОЛЬКО УКАЗЫВАТЬ РАЗНЫЕ ИМЕНА ПЕРЕМЕННЫХ.
// --------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------
// ГЛУБОКАЯ ДЕСТРУКТУРИЗАЦИЯ (Когда в Объекте есть еще Объект) ////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------
// const profile = {
//   name: 'Jacques Gluke',
//   tag: 'jgluke',
//   location: 'Ocho Rios, Jamaica',
//   avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };
// Можно Распаковать (деструктуризировать) в 2 раза
// const { name, tag, location, avatar } = profile;
// const { followers, views, likes } = stats;

// А можно в 1 раз.
// const {
//   name,
//   tag,
//   location,
//   avatar,
//   stats: { followers, views, likes },
// } = profile;
// --------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------
// ДЕСТРУКТУРИЗАЦИЯ МАССИВОВ (деструктуризируется по ПОРЯДКУ!) ////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------
// const rgb = [255, 100, 80];
// const [a, b, c] = rgb;
// console.log(rgb);

// Что бы пропустить свойство ставим запятую вместо свойства. (можно пропустить несколько раз)
// const rgb = [255, 100, 80];
// const [a, , c] = rgb;
// console.log(rgb);

// С Объекта с использованием "Object.entries()" (Возвращает Массив Массивов!)
// ---------------------------------------
// const authors = {
//   kiwi: 4,
//   poly: 7,
//   ajax: 9,
//   mango: 6,
// };

// Возвращаем Массив Массивов!
// const entries = Object.entries(authors);
// то есть получим
// [[kiwi, 4], [poly,7], [ajax, 9], [mango, 6]]
// потом перебираем этот Массив с Массивами.

// 1. Первый способ с Выводом в отдельные переменные!
// for (const entrie of entries) {
//   const name = entrie[0];
//   const rating = entrie[1];

//   console.log(name, rating);
// }

// 2. Второй способ с Деструктуризацией в переменные. 0 элемент в name а 1й в переменную rating.
// То есть 1 элемент это Массив у которго 2 Индекса, 0 и 1.
// Мы говорим Распакуй 0 и 1й элементы в такие переменные.
// for (const entrie of entries) {
//   const [name, rating] = entrie;

//   console.log(name, rating);
// }

// 3. Третий способ на место переменной "entrie" ставим Деструктуризацию, так как ссылка на массив и так храниться там.
// Проще говоря ставим распаковку на место Переменой!
// for (const [name, rating] of entries) {
//   console.log(name, rating);
// }
// --------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------
// ДЕСТРУКТУРИЗАЦИЯ со СБОРОМ - REST ////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------

// const profile = {
//   name: 'Jacques Gluke',
//   tag: 'jgluke',
//   location: 'Ocho Rios, Jamaica',
//   avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// // в переменную "restProps" собирается все остальное.
// const { name, tag, location, ...restProps } = profile;
// console.log(name, tag, location);
// console.log(restProps);

// const array = [100, 200, 300, 400, 500];
// // const [a, b, c, ...restProps] = array;

// // console.log(a, b, c);
// // console.log(restProps);

// // Ниже просто пример Распыления и поиска самого большого числа с массива.
// const result = Math.max(...array);
// console.log(result);
// --------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------
// ПАТТЕР ОБЪЕКТ НАСТРОЕК! (Применяется когда передается 3 или больше параметров!) /////////////////////////////////////////////////////
// --------------------------------------------------------------------------------------------------------------------------------------
// Передаем в Функцию Объект настроект, что бы было понятно где что значит!
// const showProfileInfo = function (userProfile) {
//   console.log(userProfile);
// };

// const profile = {
//   name: 'Jacques Gluke',
//   tag: 'jgluke',
//   location: 'Ocho Rios, Jamaica',
//   avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// Что бы функция использовала переданные свойства, мы Деструктуризируем Объект.
// Делаем Деструктуризацию в Функции Двумя способами!
// Способ - 1. (В теле Функции)
// const showProfileInfo = function (userProfile) {
//   const {
//     name,
//     tag,
//     location,
//     avatar,
//     stats: { followers, views, likes },
//   } = userProfile;

//   console.log(name, tag, location, avatar, followers, views, likes);
// };

// Способ - 2. (В подписи (параметрах) Функции)
// const showProfileInfo = function ({
//   name,
//   tag,
//   location,
//   avatar,
//   stats: { followers, views, likes },
// }) {
//   console.log(name, tag, location, avatar, followers, views, likes);
// };

// Способ - 3(Дополнение ко всем Двум!)
// Если хотим что бы что-то пошло в отдельную переменную делаем РЕСТ к avatar и stats.
// К примеру статы пойдут в переменную "restProps"
// const showProfileInfo = function ({ name, tag, location, ...restProps }) {
//   console.log(name, tag, location);
//   console.log(restProps);
// };

// showProfileInfo(profile);
// Короче говоря, в функцию мы кидаем Объект настроект, она его принимает, делает там Деструктуризацию,
// Применяет разбандеренные переменные куда нужно и возврощает Готовый результат! ЙОу!
// Так мы делаем Код чище и читабельнее, избовляясь от точек!
// --------------------------------------------------------------------------------------------------------------------------------------