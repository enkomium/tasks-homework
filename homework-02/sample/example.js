// ------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------МАССИВЫ-----------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------

// 1.
// ДОСТУП К ЭЛЕМЕНТУ

// const clients = ["Mango", "Poly", "Ajax"];

// console.log(clients[0]); // Mango
// console.log(clients[1]); // Poly
// console.log(clients[2]); // Ajax
// ------------------------------------------------------------------------------------------------------------------------------

// 2.
// ПЕРЕОПРЕДЕЛЕНИЕ​

// const clients = ["Mango", "Poly", "Ajax"];
// clients[0] = "Kiwi";
// clients[1] = "Pango";
// console.log(clients); // ["Kiwi", "Pango", "Ajax"]
// ------------------------------------------------------------------------------------------------------------------------------

// 3.
// МЕТОДЫ МАССИВА

// array.split() - преобразует строку в массив, «разбивая» ее разделителем ("" - по буквам, " " - по словам.)
// array.join() - объединяет элементы массива в строку ("" - слитно, " " - по словам, "-" - через тире.)
// array.indexOf() - возвращает первый индекс, в котором элемент со значением valueбыл найден в массиве или -1 если не чего не нашлось.
// array.includes() - проверяет, содержит ли массив элемент, возвращает true или false.
// array.push() - обавляет один или несколько элементов в конце массива.
// array.pop() - удаляет последний элемент из массива и возвращает удаленный элемент. Если массив пуст, метод возвращает undefined

// array.slice() - возвращает новый массив, содержащий копию части исходного массива, без его изменения.
// Копия создается с начинающего указанного и до последнего указанного, но не включая последний!. (смотреть теорию)
// ТОЧНО ТАКЖЕ РАБОТАЕТ И ПРОСТО СО СТРОКАМИ!!!! может вернуть новую строку не изменяя старую!
// (поскольку строки в JavaScript являются неизменяемыми).

// array.splice() - Швейцарский нож для работы с массивами, если исходный массив необходимо изменить. 
// Удаляет, добавляет и заменяет элементы в произвольном месте массива. (смотреть теорию)

// array.concat() - Объединяет два или более массивов в один. 
// Он не изменяет массив, на котором вызывается, а возвращает новый. 
// Порядок аргументов метода влияет на порядок элементов нового массива.

// ------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------ФУНКЦИИ-----------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------

// Предикатные функции возвращают только true или false. 
// Такие функции принято называть начиная с is: isLoginUnique и isLoginValid

// 1.
// В Функции пишутся ПАРАМЕТРЫ а передаем АРГУМЕНТЫ!
// ------------------------------------------------

// 2.
// return используется для передачи значения из тела функции во внешний код
// Оператор return без явно указанного значения возвращает специальное значение undefined. 
// При отсутствии returnв теле функции, она все равно вернет undefined.

// Так же
// Когда интерпретатор встречает вызов функции (или метода), 
// он приостанавливает выполнение текущего кода и начинает выполнять код из тела функции.
// --------------------------------------------------------------------------------------

// 3.
// Использование параметров по умолчанию если не понятно какое будет колличество аргументов.
// function count(countFrom = 0, countTo = 10, step = 1) {}
// -----------------------------------------------------------------------

// Псевдомассив arguments - это специальный объект, который содержит все аргументы, переданные в функцию, похожий на массив.
// Доступен только внутри функции, не является массивом! нет методов!

// Можно преобразовать в массив используя  Array.from или spread-оператор (...)
// let argsArray = Array.from(arguments) или let argsArray = [...arguments]

// Не работает в стрелочных функциях: В стрелочных функциях arguments ссылается на arguments внешней функции (если есть)
// УСТАРЕВШИЙ ПОДХОД!

// В современном JavaScript вместо arguments рекомендуется использовать остаточные параметры (...args).
// Это настоящий массив, поэтому доступны все методы.
// Делается в подписи функции - function fn(...args) {}
// Более читаемый и современный синтаксис.
// Если нужно взять первые несколько параметров отдельно, перед ...args ставим обычные параметры. - function fn(a, b, c, ...args) {}
// --------------------------------------------------------------------------------------------------------------------------

// 4.
// Паттерн "РАННИЙ ВОЗВРАТ" подход, при котором функция завершает свою работу и возвращает результат как можно раньше, 
// если выполнение дальнейшего кода не требуется. Избавляет от цепоек if-else!
// function checkAge(age) {
//     if (age < 18) {
//       return "Доступ запрещен";
//     }
//     return "Доступ разрешен";
//   }
// --------------------------------------------------------------------------------------------------------------------------

// 5.
// функциональное выражение это когда ты создаешь функцию и сразу присваиваешь её переменной
// const sayHello = function() {} Теперь, чтобы вызвать эту функцию, нужно написать sayHello()

// Разница в том что обычную функцию function sayHello() {} можно вызвать ДО ее объявления (выше кода функции)
// А Функциональное выражение, const sayHello = function() {} можно вызвать только ПОСЛЕ того, как ты её создал.

// Анонимная функция (функция без имени).
// Она может быть частью функционального выражения или передаваться как аргумент.
// Она может создаваться в разных местах, не только внутри других функций.
// -- Внутри других функций (как аргумент)
// setTimeout(function() {}
// -- Внутри функционального выражения
// const myFunction = function() {}
// -- ОТдельно сама по себе, но это бред и не кто так не делает!!!

// Почему анонимные функции обычно создаются внутри других функций?
// -- Передача как аргумент: Анонимные функции часто используются как колбэки (например, в setTimeout, map, filter).
// -- Функциональное выражение: Анонимная функция может быть присвоена переменной, чтобы её можно было вызвать позже.
// -- Замыкания: Анонимные функции часто используются для создания замыканий, где они "запоминают" контекст.

// Это удобно, когда:
// - Ты хочешь передать функцию как аргумент.
// - Ты хочешь создать функцию без имени (анонимную).
// - Ты хочешь использовать замыкания.

// ВИДЫ ФУНКЦИЙ:
// 1. Function Declaration (Объявление функции)
// Это когда ты создаёшь функцию с именем через ключевое слово function. function greet(name) {}
// Особенность : Такая функция доступна до её объявления благодаря hoisting (поднятию).

// 2. Function Expression (Функциональное выражение)
// Это когда ты создаёшь функцию и присваиваешь её переменной. const greet = function(name) {}
// Особенность : Функция доступна только после её создания.

// 3. Анонимная функция
// Это функция без имени, часто используется как часть другого кода. function() {}
// Особенность : Используется там, где имя не нужно или не имеет значения.

// 4. Стрелочная функция (Arrow Function)
// Сокращённый синтаксис для функциональных выражений, добавленный в ES6. const greet = (name) => "Hello, " + name;
// Особенности :Короткий синтаксис. Нет своего собственного this (берёт его из внешнего контекста).

// 5. Именованная функция в выражении
// Это когда ты создаёшь функциональное выражение, но даёшь ему имя внутри. const greet = function namedGreet(name) {}
// Особенность : Имя доступно только внутри самой функции.

// 6. Функция высшего порядка
// Функция, которая принимает другую функцию как аргумент или возвращает функцию.
// Особенность : Позволяет работать с функциями как с данными.

// 7. Метод объекта
// Функция, которая является частью объекта.
// Особенность : Может использовать this для доступа к свойствам объекта.

