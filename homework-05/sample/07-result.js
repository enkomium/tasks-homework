// Класс - (функция конструктор)
// Экземпляр - (Объект)
// Интерфейс - (Свойства, методы и т.п)

// ИНИЦИАЛИЗАЦИЯ - создание, активация, подготовка к работе, определение параметров.
// В контексте конструктора класса инициализация обычно означает установку начальных значений свойств объекта!
// ------------------------------------------------------------------------------------------------------------------------------------

// 1. КОНСТРУКТОР КЛАССА
// Некий метод в классе "constructor", который отвечает за установку начальных значений свойств объекта.
// Он принимает параметры, необходимые для инициализации объекта, и устанавливает их начальные значения внутри создаваемого объекта. 
// Когда мы создаем новый объект с помощью оператора new, конструктор автоматически вызывается для этого объекта, 
// и мы можем передать ему значения, которые будут использоваться для инициализации свойств объекта.

// Класс может принимать большое количество входных данных для свойств будущего объекта. 
// Поэтому к ним также можно применить паттерн «Объект параметров, передавая один объект с логично именованными свойствами, 
// вместо несвязанного набора аргументов.
// ------------------------------------------------------------------------------------------------------------------------------------

// 2. МЕТОДЫ КЛАССА
// Функции, которые привязаны к объектам этого класса.
// Делаются внутри класса и позволяют выполнять определенные действия с объектами этого класса.

// Методы класса хранятся в прототипе класса. 
// Прототип - это специальный объект, который содержит методы и свойства, доступные для всех экземпляров данного класса. 
// Когда мы создаем новый объект с помощью конструктора класса, он автоматически получает доступ ко всем методам, 
// определенным в прототипе этого класса. Это позволяет экономить память и делает код более эффективным.
// ------------------------------------------------------------------------------------------------------------------------------------

// 3. ПРИВАТНЫЕ СВОЙСТВА
// Свойства, которым нельзя напрямую обращаться извне в классе. Они используют символ "#" перед именем свойства.
// Это позволяет скрыть данные от внешнего доступа и обеспечить безопасность объекта, 
// предотвращая случайные или нежелательные изменения извне. 
// К примеру, свойство "#email" является приватным, поэтому мы не можем напрямую получить к нему доступ извне класса, 
// вызов console.log(mango.#email);. Однако мы можем использовать методы класса, такие как "getEmail" и "changeEmail", 
// чтобы получать или изменять это приватное свойство. 
// НО ЛУЧШЕ ИСПОЛЬЗОВАТЬ Геттеры и сеттеры вместо обычнх методов!

// Извне класса означает за пределами самого класса. 
// Другими словами, это любое место в коде программы, которое не является частью определения класса.
// ------------------------------------------------------------------------------------------------------------------------------------

// 4. ГЕТТЕРЫ И СЕТТЕРЫ
// Специальные методы в классе, которые позволяют получать и устанавливать значения приватных свойств объекта.

// - Геттер выполняется при попытке ПОЛУЧИТЬ значение свойства, а сеттер - при попытке его ИЗМЕНИТЬ.
// - Геттеры и сеттеры хорошо использовать для простых операций чтения и изменения значения свойств, 
// особенно приватных, как их публичный интерфейс. Для работы со свойством которое хранит массив или объект они не подойдут.
// - Плюс в том, что это методы, а значит при записи можно выполнить дополнительный код, 
// например с какими-то проверками, в отличии от выполнениях этой же операции напрямую со свойством.
// Геттер не может называться так же как совйство кторое он Описывает, поэтому СВОЙСТВУ ставят нижнее подчеркивание к имени _
// а геттер записывают без него (при вызове или возврате свойства тоже ставят подчеркивание)
// Использовать тогда когда внешний код будет читать и записывать, когда все из вне будет к нему обращаться на прямую
// ПРОИТАТЬ ПРО СВОЙСТВА Object.defineProperty() типа как создаются Геттеры и Сеттеры

// Преимущества геттеров и сеттеров:
// * Упрощение и защита доступа к данным объекта: 
//   Они позволяют скрыть реализацию приватных свойств и предоставляют контролируемый интерфейс доступа к данным.
// * Повышение безопасности: 
//   Геттеры и сеттеры могут обеспечить проверку ввода и выхода, что позволяет избежать ошибок при работе с данными.
// * Гибкость: 
//   Они позволяют легко изменять реализацию доступа к данным без изменения интерфейса.
// ------------------------------------------------------------------------------------------------------------------------------------

// 5. СТАТИЧЕСКИЕ СВОЙСТВА
// - Кроме публичных и приватных свойств будущего экземпляра, в классе можно объявить его собственные свойства, 
// доступные только классу, но не его экземплярам - статические свойства (static). 
// Они полезны для хранения информации относящейся к самому классу.
// Статические свойства объявляются в теле класса. Перед именем свойства добавляется ключевое слово static.
// - Статические свойства также могут быть приватные, то есть доступные только внутри класса. (обращение через метод)
// Для этого имя свойства должно начинаться с символа #, также как приватные свойства. 
// Обращение к приватному статическому свойству вне тела класса вызовет ошибку.
// При обращении нужно указывать ОБЪЕКТ (User.TYPES) а не this

// Обычно используются для хранения общих для всех экземпляров класса данных или констант, 
// которые не должны меняться от экземпляра к экземпляру.
// ------------------------------------------------------------------------------------------------------------------------------------

// 6. СТАТИЧЕСКИЕ МЕТОДЫ.
// Методы, которые привязаны к самому классу, а не к его экземплярам. 
// Они вызываются на самом классе, а не на объектах, созданных из этого класса.

// Основные моменты о статических методах:
// * Привязанность к классу: 
//   Они принадлежат самому классу, а не его экземплярам, что означает, что они могут быть вызваны без создания объекта этого класса.

// * Область видимости: 
//   Они могут обращаться только к другим статическим членам класса и не имеют доступа к экземплярам класса через ключевое слово this.

// * Использование: 
//   Они обычно используются для выполнения операций, связанных с самим классом или его свойствами, 
//   которые не зависят от конкретного экземпляра.

// В классе можно объявить не только методы будущего экземпляра, но и методы доступные только классу - статические методы, 
// которые могут быть как публичные, так и приватные. 
// Синтаксис объявления аналогичен статическим свойствам, за исключением того, что значением будет метод.
// Особенность статических методов в том, что во время их вызова ключевое слово this ссылается на сам класс. 
// Это значит, что статический метод может получить доступ к статическим свойствам класса, но не к свойствам экземпляра. 
// Логично, потому что статические методы вызывает сам класс, а не его экземпляры.
// ------------------------------------------------------------------------------------------------------------------------------------

// 7. НАСЛЕДОВАНИЕ КЛАССОВ (помнить про супер при наследовании)
// Механизм, который позволяет новому классу, называемому дочерним классом, наследовать свойства и методы от другого класса, 
// называемого родительским классом или суперклассом.

// Важно понимать, что приватные свойства в JavaScript доступны только внутри класса, в котором они были определены. 
// Это означает, что если дочерний класс имеет доступ к приватному свойству, то он не может напрямую обращаться к нему извне.
// Вместо этого Дочерний класс может использовать его через публичные методы, такие как геттеры и сеттеры, 
// предоставленные родительским классом. Это обеспечивает контролируемый доступ к приватным данным извне класса.
// Типа в главном классе есть приватное свойство с геттерами и сеттерами для его управления, если мы наследуем его и делаем 
// Экземпляр от дочернего класса, можем обратиться с этого Экземпляра (объекта) к методам (геттерам и сеттерам) и сделать что-то
// ------------------------------------------------------------------------------------------------------------------------------------

// 8. КОНСТРУКТОР ДОЧЕРНЕГО КЛАССА (super)
// Конструктор дочернего класса в JavaScript выполняет две основные задачи:

// 1. Вызов конструктора родительского класса: 
// Конструктор дочернего класса может вызывать конструктор родительского класса с помощью ключевого слова super. 
// Это позволяет унаследованным свойствам и методам родительского класса быть инициализированными в дочернем классе.

// 2. Инициализация собственных свойств дочернего класса: 
// Конструктор дочернего класса может также инициализировать свои собственные свойства. 
// Это могут быть как новые свойства, так и переопределенные родительские свойства.
// ------------------------------------------------------------------------------------------------------------------------------------

// 9. МЕТОДЫ ДОЧЕРНЕГО КЛАССА
// Это функции, которые определяются внутри дочернего класса и позволяют выполнять определенные действия с объектами этого класса.
// В дочернем классе можно объявлять методы которые будут доступны только его экземплярам, 
// нужно просто объявить этот метод внутри конструктора класса
